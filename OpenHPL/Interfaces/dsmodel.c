#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model OpenHPL.Examples.HPSimpleAirCushionSurgeTank
 Dymola Version 2020 (64-bit), 2019-04-10 translated this at Thu Nov 21 07:42:34 2019

   */

#include <matrixop.h>
/* Declaration of C-structs */
struct DymStruc0;
struct DymStruc0 {
  int  id_0member;
};
DYMOLA_STATIC struct DymStruc0 DymStruc0_construct(int   id_02) {
  struct DymStruc0 dummy_0;
  dummy_0.id_0member = id_02;
  return dummy_0;
}
/* Prototypes for functions used in model */
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmax_M(
  struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmin_M(
  struct DymStruc0 tableID0_0);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DValue_M(struct 
  DymStruc0 tableID0_0, int  icol0_0, double  u0_0);
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int  extrapolation0_0, int  
  verboseRead0_0, int id_, int alwaysMakeNew_);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0);
struct Modelica_Math_Matrices_LAPACK_dgetrf_M_struct {
  RealArray    LU0_0_0member;
  IntegerArray    pivots0_0_0member;
  int   info0_0_0member;
};
DYMOLA_STATIC struct Modelica_Math_Matrices_LAPACK_dgetrf_M_struct 
  Modelica_Math_Matrices_LAPACK_dgetrf_M(RealArray   A0_0);
struct Modelica_Math_Matrices_LAPACK_dgetri_M_struct {
  RealArray    inv0_0_0member;
  int   info0_0_0member;
};
DYMOLA_STATIC struct Modelica_Math_Matrices_LAPACK_dgetri_M_struct 
  Modelica_Math_Matrices_LAPACK_dgetri_M(RealArray   LU0_0, IntegerArray   
  pivots0_0);
DYMOLA_STATIC RealArray    Modelica_Math_Matrices_inv(RealArray   A0_0);
DYMOLA_STATIC int   Modelica_Utilities_Strings_isEmpty(const char*  string0_0);
DYMOLA_STATIC double   OpenHPL_Functions_DarcyFriction_Friction(double  v0_0, 
  double  D0_0, double  L0_0, double  rho0_0, double  mu0_0, double  eps0_0);
DYMOLA_STATIC double   OpenHPL_Functions_DarcyFriction_fDarcy(double  Nx_0Re, 
  double  D0_0, double  epsilon0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
discrete output Real uMax "Maximum abscissa value in table";

external "C" uMax = ModelicaStandardTables_CombiTable1D_maximumAbscissa(tableID);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax;

  */
extern double (ModelicaStandardTables_CombiTable1D_maximumAbscissa)(void*);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmax_M(
  struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax")
  {
    /* Declare outputs and temporaries */
    double   uMax0_0;
    uMax0_0=0;
    /* Start of real code */
    {
      uMax0_0 = (ModelicaStandardTables_CombiTable1D_maximumAbscissa)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return uMax0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
discrete output Real uMin "Minimum abscissa value in table";

external "C" uMin = ModelicaStandardTables_CombiTable1D_minimumAbscissa(tableID);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin;

  */
extern double (ModelicaStandardTables_CombiTable1D_minimumAbscissa)(void*);
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmin_M(
  struct DymStruc0 tableID0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin")
  {
    /* Declare outputs and temporaries */
    double   uMin0_0;
    uMin0_0=0;
    /* Start of real code */
    {
      uMin0_0 = (ModelicaStandardTables_CombiTable1D_minimumAbscissa)(
        externalTable_[tableID0_0.id_0member].obj_);
      }
    /* Output section */
    PopContext()
    return uMin0_0;
  }}

/* Flattened Modelica model:

function Modelica.Blocks.Tables.Internal.getTable1DValue
input Modelica.Blocks.Types.ExternalCombiTable1D tableID;
input Integer icol;
discrete input Real u;
discrete output Real y;

external "C" y = ModelicaStandardTables_CombiTable1D_getValue(tableID, icol, u);
annotation(derivative=Modelica.Blocks.Tables.Internal.getDerTable1DValue, Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Blocks.Tables.Internal.getTable1DValue;

  */
extern double (ModelicaStandardTables_CombiTable1D_getValue)(void*, int , double );
DYMOLA_STATIC double   Modelica_Blocks_Tables_Internal_getTable1DValue_M(struct 
  DymStruc0 tableID0_0, int  icol0_0, double  u0_0) {
  PushContext("Modelica.Blocks.Tables.Internal.getTable1DValue")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
    {
      y0_0 = (ModelicaStandardTables_CombiTable1D_getValue)(externalTable_[
        tableID0_0.id_0member].obj_, icol0_0, u0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}

/* Flattened Modelica model:

function constructor
input String tableName "Table name";
input String fileName "File name";
discrete input Real table[:, :];
input Integer columns[:];
input Modelica.Blocks.Types.Smoothness smoothness;
input Modelica.Blocks.Types.Extrapolation extrapolation(start = Modelica.Blocks.Types.Extrapolation.LastTwoPoints);
input Boolean verboseRead(start = true) "= true: Print info message; = false: No info message";
output Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" externalCombiTable1D = ModelicaStandardTables_CombiTable1D_init2(fileName, tableName, table, size(table, 1), size(table, 2), columns, size(columns, 1), smoothness, extrapolation, verboseRead);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end constructor;

  */
extern void* (ModelicaStandardTables_CombiTable1D_init2)(const char* , 
  const char* , double  const *, size_t, size_t, int  const *, size_t, int , int ,
   int );
DYMOLA_STATIC struct DymStruc0  Modelica_Blocks_Types_ExternalCombiTable1D_M(
  const char*  tableName0_0, const char*  fileName0_0, RealArray   table0_0, 
  IntegerArray   columns0_0, int  smoothness0_0, int  extrapolation0_0, int  
  verboseRead0_0, int id_, int alwaysMakeNew_) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D")
  {
    /* Declare outputs and temporaries */
    struct DymStruc0  externalCombiTable1D0_0;
    externalCombiTable1D0_0.id_0member=0;
    /* Start of real code */
    {
      externalCombiTable1D0_0.id_0member=id_;
      if (externalTable_[id_].destructor_ && externalTable_[id_].obj_ && alwaysMakeNew_) {
      void*x_=externalTable_[id_].obj_;
      externalTable_[id_].obj_=0;
      (*(externalTable_[id_].destructor_))(x_);
      } else if (!externalTable_[id_].destructor_) {externalTable_[id_].obj_=0;}
      #if (defined(_OPENMP) && !defined(DISABLE_DYMOLA_OPENMP))
      if (!(externalTable_[id_].haveLock_)) {omp_init_lock(&(externalTable_[id_].lockExternal_));externalTable_[id_].haveLock_=1;}
      #endif
      externalTable_[id_].destructor_=Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M;

        if (!externalTable_[id_].obj_) externalTable_[id_].obj_ = (
        ModelicaStandardTables_CombiTable1D_init2)(fileName0_0, tableName0_0, 
        table0_0.data, table0_0.dims[1-1], table0_0.dims[2-1], columns0_0.data, 
        columns0_0.dims[1-1], smoothness0_0, extrapolation0_0, verboseRead0_0);
      }
    /* Output section */
    PopContext()
    return externalCombiTable1D0_0;
  }}

/* Flattened Modelica model:

function destructor
input Modelica.Blocks.Types.ExternalCombiTable1D externalCombiTable1D;

external "C" ModelicaStandardTables_CombiTable1D_close(externalCombiTable1D);
annotation(Library={"ModelicaIO", "ModelicaMatIO", "ModelicaStandardTables", "zlib"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end destructor;

  */
extern void (ModelicaStandardTables_CombiTable1D_close)(void*);
DYMOLA_STATIC void Modelica_Blocks_Types_ExternalCombiTable1D_destructor_M(
  void* externalCombiTable1D0_0) {
  PushContext("Modelica.Blocks.Types.ExternalCombiTable1D.destructor")
  {
    /* Declare outputs and temporaries */
    /* Start of real code */
    {
      (ModelicaStandardTables_CombiTable1D_close)(externalCombiTable1D0_0);
      }
    /* Output section */
    PopContext()
    return ;
  }}

/* Flattened Modelica model:

function Modelica.Utilities.Strings.isEmpty
input String string;
output Boolean result "True, if string is empty";
protected 
Integer nextIndex;
Integer len;
public 
algorithm 
nextIndex := ModelicaStrings_skipWhiteSpace(string, 1);
len := ModelicaStrings_length(string);
if (len < 1 or nextIndex > len) then 
result := true;
else
result := false;
end if;
end Modelica.Utilities.Strings.isEmpty;

  */
DYMOLA_STATIC int   Modelica_Utilities_Strings_isEmpty(const char*  string0_0) {
  PushContext("Modelica.Utilities.Strings.isEmpty")
  {
    /* Declare outputs and temporaries */
    int   result0_0;
    int   nextIndex0_0;
    int   len0_0;
    result0_0=0;
    nextIndex0_0=0;
    len0_0=0;
    /* Start of real code */
      nextIndex0_0 = ModelicaStrings_skipWhiteSpace(string0_0, 1);
      len0_0 = ModelicaStrings_length(string0_0);
      if (len0_0 < 1 OR nextIndex0_0 > len0_0) {
        result0_0 = true;
      }
      else{
        result0_0 = false;
      }
    /* Output section */
    PopContext()
    return result0_0;
  }}

/* Flattened Modelica model:

function OpenHPL.Functions.DarcyFriction.Friction
discrete input Real v(unit = "m/s") "Flow velocity";
discrete input Real D(unit = "m", min = 0.0) "Pipe diameter";
discrete input Real L(unit = "m") "Pipe length";
discrete input Real rho(unit = "kg/m3", displayUnit = "g/cm3", min = 0.0) "Density";
discrete input Real mu(unit = "Pa.s", min = 0.0) "Dynamic viscosity of water";
discrete input Real eps(unit = "m", min = 0.0) "Pipe roughness height";
discrete output Real F_f(unit = "N") "Friction force";
protected 
discrete Real N_Re(unit = "1");
discrete Real f;
public 
algorithm 
N_Re := rho*abs(v)*D/mu;
f := OpenHPL.Functions.DarcyFriction.fDarcy(N_Re, D, eps);
F_f := 1.5707963267948966*f*rho*L*v*abs(v)*D/4;
end OpenHPL.Functions.DarcyFriction.Friction;

  */
DYMOLA_STATIC double   OpenHPL_Functions_DarcyFriction_Friction(double  v0_0, 
  double  D0_0, double  L0_0, double  rho0_0, double  mu0_0, double  eps0_0) {
  PushContext("OpenHPL.Functions.DarcyFriction.Friction")
  {
    /* Declare outputs and temporaries */
    double   Fx_0f;
    double   Nx_0Re;
    double   f0_0;
    Fx_0f=0;
    Nx_0Re=0;
    f0_0=0;
    /* Start of real code */
      Nx_0Re = divGuarded(rho0_0*fabs(v0_0)*D0_0,"rho*abs(v)*D",mu0_0,"mu");
      f0_0 = OpenHPL_Functions_DarcyFriction_fDarcy(Nx_0Re, D0_0, eps0_0);
      Fx_0f = 1.5707963267948966*f0_0*rho0_0*L0_0*v0_0*fabs(v0_0)*D0_0/(double)(4);
    /* Output section */
    PopContext()
    return Fx_0f;
  }}

/* Flattened Modelica model:

function OpenHPL.Functions.DarcyFriction.fDarcy
discrete input Real N_Re(unit = "1") "Reynold number";
discrete input Real D(unit = "m", min = 0.0) "Pipe diameter";
discrete input Real epsilon(unit = "m", min = 0.0) "Pipe roughness height";
discrete output Real fD "Darcy friction factor";
protected 
discrete Real arg;
discrete Real N_Re_lam(start = 2100, unit = "1");
discrete Real N_Re_tur(start = 2300, unit = "1");
discrete Real X[4, 4];
discrete Real Y[4];
discrete Real K[4];
public 
algorithm 
X := [N_Re_lam^3, N_Re_lam^2, N_Re_lam, 1; N_Re_tur^3, N_Re_tur^2, N_Re_tur, 1; 3*N_Re_lam^2, 2*N_Re_lam, 1, 0; 3*N_Re_tur^2, 2*N_Re_tur, 1, 0];
Y := {64/N_Re_lam, 1/(2*log10(epsilon/3.7/D+5.74/N_Re_tur^0.9))^2,  -64/N_Re_lam^2,  -0.079/N_Re_tur^1.25};
K := Modelica.Math.Matrices.inv(X)*Y;
arg := epsilon/3.7/D+5.74/(N_Re+0.001)^0.9;
if (N_Re <= 0) then 
fD := 0;
elseif (N_Re <= 2100) then 
fD := 64/N_Re;
elseif (N_Re < 2300) then 
fD := K[1]*N_Re^3+K[2]*N_Re^2+K[3]*N_Re+K[4];
else
fD := 1/(2*log10(arg))^2;
end if;
end OpenHPL.Functions.DarcyFriction.fDarcy;

  */
DYMOLA_STATIC double   OpenHPL_Functions_DarcyFriction_fDarcy(double  Nx_0Re, 
  double  D0_0, double  epsilon0_0) {
  PushContext("OpenHPL.Functions.DarcyFriction.fDarcy")
  {
    /* Declare outputs and temporaries */
    double   fD0_0;
    double   arg0_0;
    double   Nx_0Rex_0lam;
    double   Nx_0Rex_0tur;
    RealArray    X0_0;
    RealArray    Y0_0;
    RealArray    K0_0;
    MarkObject retmark_ = PushMark();
    fD0_0=0;
    arg0_0=0;
    Nx_0Rex_0lam = 2100;
    Nx_0Rex_0tur = 2300;
    X0_0=RealTemporary( 2, 4, 4);
    PushMark();
    RealFillAssign( X0_0, 0);
    Y0_0=RealTemporary( 1, 4);
    PushMark();
    RealFillAssign( Y0_0, 0);
    K0_0=RealTemporary( 1, 4);
    PushMark();
    RealFillAssign( K0_0, 0);
    /* Start of real code */
      RealAssign (X0_0, RealCat( 1, 4, RealCat( 2, 4, RealPromoteScalar( 
        powUnguarded(Nx_0Rex_0lam, 3), 2), RealPromoteScalar( sqr(Nx_0Rex_0lam),
         2), RealPromoteScalar( Nx_0Rex_0lam, 2), RealPromoteScalar( 1.0, 2)), 
        RealCat( 2, 4, RealPromoteScalar( powUnguarded(Nx_0Rex_0tur, 3), 2), 
        RealPromoteScalar( sqr(Nx_0Rex_0tur), 2), RealPromoteScalar( 
        Nx_0Rex_0tur, 2), RealPromoteScalar( 1.0, 2)), RealCat( 2, 4, 
        RealPromoteScalar( 3*sqr(Nx_0Rex_0lam), 2), RealPromoteScalar( 2*
        Nx_0Rex_0lam, 2), RealPromoteScalar( 1.0, 2), RealPromoteScalar( 0.0, 2)),
         RealCat( 2, 4, RealPromoteScalar( 3*sqr(Nx_0Rex_0tur), 2), 
        RealPromoteScalar( 2*Nx_0Rex_0tur, 2), RealPromoteScalar( 1.0, 2), 
        RealPromoteScalar( 0.0, 2))));
      Release();
      RealAssign (Y0_0, RealScalarArray ( 4, divGuarded(64,"64",Nx_0Rex_0lam,
        "N_Re_lam"), divinvGuarded(sqr(2*log10Guarded(divGuarded(epsilon0_0/
        (double)(3.7),"epsilon/3.7",D0_0,"D")+divGuarded(5.74,"5.74",powGuarded(
        Nx_0Rex_0tur,"N_Re_tur",0.9,"0.9"),"N_Re_tur^0.9"),"epsilon/3.7/D+5.74/N_Re_tur^0.9")),
        "(2*log10(epsilon/3.7/D+5.74/N_Re_tur^0.9))^2"),  -divGuarded(64,"64",
        sqr(Nx_0Rex_0lam),"N_Re_lam^2"),  -divGuarded(0.079,"0.079",powGuarded(
        Nx_0Rex_0tur,"N_Re_tur",1.25,"1.25"),"N_Re_tur^1.25")));
      Release();
      RealAssign (K0_0, RealMultiplyMV (Modelica_Math_Matrices_inv(X0_0),Y0_0));
      Release();
      arg0_0 = divGuarded(epsilon0_0/(double)(3.7),"epsilon/3.7",D0_0,"D")+
        divGuarded(5.74,"5.74",powGuarded(Nx_0Re+0.001,"N_Re+0.001",0.9,"0.9"),
        "(N_Re+0.001)^0.9");
      if (Nx_0Re <= 0) {
        fD0_0 = 0;
      }
      else if (Nx_0Re <= 2100) {
        fD0_0 = divGuarded(64,"64",Nx_0Re,"N_Re");
      }
      else if (Nx_0Re < 2300) {
        fD0_0 = RealVectorElement( K0_0, (SizeType)(1))*powUnguarded(Nx_0Re, 3)+
          RealVectorElement( K0_0, (SizeType)(2))*sqr(Nx_0Re)+RealVectorElement( 
          K0_0, (SizeType)(3))*Nx_0Re+RealVectorElement( K0_0, (SizeType)(4));
      }
      else{
        fD0_0 = divinvGuarded(sqr(2*log10Guarded(arg0_0,"arg")),"(2*log10(arg))^2");
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return fD0_0;
  }}

/* Flattened Modelica model:

function Modelica.Math.Matrices.inv
discrete input Real A[:, size(A, 1)];
discrete output Real invA[size(A, 1), size(A, 2)] "Inverse of matrix A";
protected 
Integer info;
Integer pivots[size(A, 1)] "Pivot vector";
discrete Real LU[size(A, 1), size(A, 2)] "LU factors of A";
public 
algorithm 
(LU, pivots, info)  := Modelica.Math.Matrices.LAPACK.dgetrf(A);
assert(info == 0, "Calculating an inverse matrix with function
\"Matrices.inv\" is not possible, since matrix A is singular.");
invA := Modelica.Math.Matrices.LAPACK.dgetri(LU, pivots);
end Modelica.Math.Matrices.inv;

  */
DYMOLA_STATIC RealArray    Modelica_Math_Matrices_inv(RealArray   A0_0) {
  PushContext("Modelica.Math.Matrices.inv")
  AssertModelica(DYNSizeSimple(A0_0,2)==DYNSizeSimple(A0_0, 1),"size(A, 2) == size(A, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    invA0_0;
    int   info0_0;
    IntegerArray    pivots0_0;
    RealArray    LU0_0;
    MarkObject retmark_ = PushMark();
    invA0_0=RealTemporary( 2, DYNSizeSimple(A0_0, 1), DYNSizeSimple(A0_0, 2));
    RePushMark(&retmark_);
    RealFillAssign( invA0_0, 0);
    info0_0=0;
    pivots0_0=IntegerTemporary( 1, DYNSizeSimple(A0_0, 1));
    PushMark();
    IntegerFillAssign( pivots0_0, 0);
    LU0_0=RealTemporary( 2, DYNSizeSimple(A0_0, 1), DYNSizeSimple(A0_0, 2));
    PushMark();
    RealFillAssign( LU0_0, 0);
    /* Start of real code */
      {
        struct Modelica_Math_Matrices_LAPACK_dgetrf_M_struct dummy_mult_=
          Modelica_Math_Matrices_LAPACK_dgetrf_M(A0_0);
        RealAssign (LU0_0, dummy_mult_.LU0_0_0member);
        IntegerAssign (pivots0_0, dummy_mult_.pivots0_0_0member);
        info0_0 = dummy_mult_.info0_0_0member;
      }
      Release();
      AssertModelica(info0_0 == 0,"info == 0", "Calculating an inverse matrix with function\n\"Matrices.inv\" is not possible, since matrix A is singular.");
      RealAssign (invA0_0, Modelica_Math_Matrices_LAPACK_dgetri_M(LU0_0, 
        pivots0_0).inv0_0_0member);
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return invA0_0;
  }}

/* Flattened Modelica model:

function Modelica.Math.Matrices.LAPACK.dgetrf
discrete input Real A[:, :] "Square or rectangular matrix";
discrete output Real LU[size(A, 1), size(A, 2)](start = A);
output Integer pivots[min(size(A, 1), size(A, 2))] "Pivot vector";
output Integer info "Information";
protected 
Integer m(start = size(A, 1));
Integer n(start = size(A, 2));
Integer lda(start = max(1, size(A, 1)));
public 
external "Fortran 77" dgetrf(m, n, LU, lda, pivots, info);
annotation(Library={"lapack"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Math.Matrices.LAPACK.dgetrf;

  */
extern int (dgetrf_)(int  *, int  *, double  *, int  *, int  *, int  *);
DYMOLA_STATIC struct Modelica_Math_Matrices_LAPACK_dgetrf_M_struct 
  Modelica_Math_Matrices_LAPACK_dgetrf_M(RealArray   A0_0) {
  PushContext("Modelica.Math.Matrices.LAPACK.dgetrf")
  {
    /* Declare outputs and temporaries */
    RealArray    LU0_0;
    IntegerArray    pivots0_0;
    int   info0_0;
    int   m0_0;
    int   n0_0;
    int   lda0_0;
    MarkObject retmark_ = PushMark();
    LU0_0=RealTemporary( 2, DYNSizeSimple(A0_0, 1), DYNSizeSimple(A0_0, 2));
    RePushMark(&retmark_);
    RealAssign (LU0_0, A0_0);
    Release();
    pivots0_0=IntegerTemporary( 1, IntegerBmin(DYNSizeSimple(A0_0, 1), 
      DYNSizeSimple(A0_0, 2)));
    RePushMark(&retmark_);
    IntegerFillAssign( pivots0_0, 0);
    info0_0=0;
    m0_0 = DYNSizeSimple(A0_0, 1);
    n0_0 = DYNSizeSimple(A0_0, 2);
    lda0_0 = IntegerBmax(1, DYNSizeSimple(A0_0, 1));
    /* Start of real code */
    {
      RealArray   helper_2 = RealSwitchMajor( LU0_0);
      (void)(dgetrf_)(& m0_0, & n0_0, helper_2.data, & lda0_0, pivots0_0.data, 
        & info0_0);
      RealSwitchMajorAssign( LU0_0,helper_2);
      Release();
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Math_Matrices_LAPACK_dgetrf_M_struct out_;
      out_.LU0_0_0member = LU0_0;
      out_.pivots0_0_0member = pivots0_0;
      out_.info0_0_0member = info0_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Math.Matrices.LAPACK.dgetri
discrete input Real LU[:, size(LU, 1)] "LU factorization of dgetrf of a square matrix";
input Integer pivots[size(LU, 1)] "Pivot vector of dgetrf";
discrete output Real inv[size(LU, 1), size(LU, 2)](start = LU) "Inverse of matrix P*L*U";
output Integer info;
protected 
Integer n(start = size(LU, 1));
Integer lda(start = max(1, size(LU, 1)));
Integer lwork(start = max(1, min(10, size(LU, 1))*size(LU, 1))) "Length of work array";
discrete Real work[max(1, min(10, size(LU, 1))*size(LU, 1))];
public 
external "Fortran 77" dgetri(n, inv, lda, pivots, work, lwork, info);
annotation(Library={"lapack"}, LibraryDirectory="modelica://Modelica/Resources/Library");
end Modelica.Math.Matrices.LAPACK.dgetri;

  */
extern int (dgetri_)(int  *, double  *, int  *, int  const *, double  *, int  *,
   int  *);
DYMOLA_STATIC struct Modelica_Math_Matrices_LAPACK_dgetri_M_struct 
  Modelica_Math_Matrices_LAPACK_dgetri_M(RealArray   LU0_0, IntegerArray   
  pivots0_0) {
  PushContext("Modelica.Math.Matrices.LAPACK.dgetri")
  AssertModelica(DYNSizeSimple(LU0_0,2)==DYNSizeSimple(LU0_0, 1),
    "size(LU, 2) == size(LU, 1)","Dimension check of input to function failed");
  AssertModelica(DYNSizeSimple(pivots0_0,1)==DYNSizeSimple(LU0_0, 1),
    "size(pivots, 1) == size(LU, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    inv0_0;
    int   info0_0;
    int   n0_0;
    int   lda0_0;
    int   lwork0_0;
    RealArray    work0_0;
    MarkObject retmark_ = PushMark();
    inv0_0=RealTemporary( 2, DYNSizeSimple(LU0_0, 1), DYNSizeSimple(LU0_0, 2));
    RePushMark(&retmark_);
    RealAssign (inv0_0, LU0_0);
    Release();
    info0_0=0;
    n0_0 = DYNSizeSimple(LU0_0, 1);
    lda0_0 = IntegerBmax(1, DYNSizeSimple(LU0_0, 1));
    lwork0_0 = IntegerBmax(1, IntegerBmin(10, DYNSizeSimple(LU0_0, 1))*
      DYNSizeSimple(LU0_0, 1));
    work0_0=RealTemporary( 1, IntegerBmax(1, IntegerBmin(10, DYNSizeSimple(LU0_0,
       1))*DYNSizeSimple(LU0_0, 1)));
    PushMark();
    RealFillAssign( work0_0, 0);
    /* Start of real code */
    {
      RealArray   helper_1 = RealSwitchMajor( inv0_0);
      (void)(dgetri_)(& n0_0, helper_1.data, & lda0_0, pivots0_0.data, work0_0
        .data, & lwork0_0, & info0_0);
      RealSwitchMajorAssign( inv0_0,helper_1);
      Release();
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Math_Matrices_LAPACK_dgetri_M_struct out_;
      out_.inv0_0_0member = inv0_0;
      out_.info0_0_0member = info0_0;
      return out_;
    }
  }}
/* DSblock C-code: */

#define NX_    3
#define NX2_   1
#define NU_    0
#define NY_    0
#define NW_    76
#define NP_    47
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   2
#define MAXAuxStrLen_   500
#define NHash1_ 2144692974
#define NHash2_ 1183760015
#define NHash3_ 0
#define NI_    0
#define NRelF_ 0
#define NRel_  0
#define NTim_  2
#define NSamp_ 0
#define NCons_ 0
#define NA_    21
#define SizePre_ 0
#define SizeEq_ 9
#define SizeDelay_ 0
#define QNLmax_ 1
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 81
#define NGlobalHelpI_ 31
#ifndef NExternalObject_
#define NExternalObject_ 1
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="OpenHPL.Examples.HPSimpleAirCushionSurgeTank";
#endif
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=0;
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,2) = false;
DYNX(W_,3) = false;
DYNX(W_,25) = 1;
#endif
DYNSetAuxString(did_, "NoName", 0);
DYNSetAuxString(did_, "NoName", 1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,38) = 2;
DYNX(W_,1) = false;
DYNX(W_,13) = true;
DYNX(W_,27) = false;
DYNX(W_,39) = 1;
DYNX(W_,40) = 2;
DYNX(W_,41) = false;
DYNX(W_,6) = 0.0;
DYNX(W_,17) = 0.0;
DYNX(W_,15) = 0.0;
DYNX(W_,16) = 0.0;
DYNX(W_,19) = 0.0;
DYNX(W_,7) = 0.0;
DYNX(W_,10) = 0.0;
DYNX(W_,61) = 0.0;
DYNX(W_,47) = 4100000.0;
DYNX(W_,9) = 0.0;
DYNX(W_,8) = 0.0;
DYNX(W_,24) = 0.0;
DYNX(W_,20) = 0.0;
DYNX(W_,22) = 0.0;
DYNX(W_,21) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
DYNX(DYNhelp,0) = divinvGuarded(DYNX(DP_,1),"Const.rho");
DYNX(W_,0) = DYNX(DYNhelp,0)*1E-06;
DYNX(W_,28) = DYNX(DP_,21);
DYNX(W_,29) = DYNX(DP_,22);
DYNX(W_,30) = DYNX(DP_,23);
DYNX(W_,31) = DYNX(DP_,24);
DYNX(W_,32) = DYNX(DP_,25);
DYNX(W_,33) = DYNX(DP_,26);
DYNX(W_,34) = DYNX(DP_,27);
DYNX(W_,35) = DYNX(DP_,28);
DYNX(W_,36) = DYNX(DP_,29);
DYNX(W_,37) = DYNX(DP_,30);
InitialBoundSection
DYNX(DYNhelp,1) = (PushModelContext(1,"Modelica.Utilities.Strings.isEmpty(turbine.look_up_table.fileName)")
  Modelica_Utilities_Strings_isEmpty("NoName"));
PopModelContext();
{
  struct DymStruc0 dummy_DymStruc0;
  dummy_DymStruc0 = (PushModelContext(1,"Modelica.Blocks.Types.ExternalCombiTable1D((if turbine.look_up_table.tableOnFile then turbine.look_up_table.tableName else \"NoName\"), (if turbine.look_up_table.tableOnFile and turbine.look_up_table.fileName <> \"NoName\" and  not Modelica.Utilities.Strings.isEmpty(turbine.look_up_table.fileName) then turbine.look_up_table.fileName else \"NoName\"), turbine.look_up_table.table, turbine.look_up_table...")
    Modelica_Blocks_Types_ExternalCombiTable1D_M(IF DYNX(W_,27) THEN "NoName"
     ELSE "NoName", IF DYNX(W_,27) AND (strcmp("NoName", "NoName")!=0) AND  NOT 
    DYNX(DYNhelp,1) THEN "NoName" ELSE "NoName", RealTemporaryDense( 
    &DYNX(W_,28), 2, 5, 2), IntegerTemporaryDense( &DYNX(W_,38), 1, 1), 
    (Integer)(DYNX(W_,39)), (Integer)(DYNX(W_,40)), (Integer)(IF DYNX(W_,27)
     THEN DYNX(DP_,32) ELSE false), 0, 1));
  DYNX(W_,44) = dummy_DymStruc0.id_0member;
PopAllMarks();
}
BoundParameterSection
DYNX(W_,42) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmin(\nturbine.look_up_table.tableID)")
  Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmin_M(DymStruc0_construct(
  (Integer)(DYNX(W_,44)))));
PopModelContext();
DYNX(W_,43) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DAbscissaUmax(\nturbine.look_up_table.tableID)")
  Modelica_Blocks_Tables_Internal_getTable1DAbscissaUmax_M(DymStruc0_construct(
  (Integer)(DYNX(W_,44)))));
PopModelContext();
DYNX(W_,45) = DYNX(DP_,3);
DYNX(W_,46) = DYNX(W_,1);
DYNX(W_,62) = DYNX(DP_,3);
DYNX(W_,63) = DYNX(W_,1);
DYNX(W_,64) = DYNX(DP_,7);
BoundParameterConstantSection
DYNX(W_,67) = 0.7853981633974483*sqr(DYNX(DP_,41));
DYNX(W_,68) = 0.7853981633974483*sqr(DYNX(DP_,42));
DYNX(W_,51) = 0.7853981633974483*sqr(DYNX(DP_,35));
DYNX(DYNhelp,2) = divinvGuarded(DYNX(DP_,34),"airCushionSurgeTank.L");
DYNX(W_,53) = DYNX(DYNhelp,2)*DYNX(DP_,33);
DYNX(W_,65) = 0.5*(DYNX(DP_,41)+DYNX(DP_,42));
DYNX(W_,69) = 0.7853981633974483*sqr(DYNX(W_,65));
DYNX(W_,66) = DYNX(DP_,1)*DYNX(W_,69)*DYNX(DP_,40);
DYNX(DYNhelp,3) = divinvGuarded(DYNX(DP_,40),"pipe.L");
DYNX(W_,70) = DYNX(DYNhelp,3)*DYNX(DP_,39);
DYNX(W_,18) = IF DYNX(DP_,15) THEN DYNX(DP_,16) ELSE divGuarded(divGuarded(
  DYNX(DP_,18),"turbine.V_dot_n",sqrtGuarded(divGuarded(DYNX(DP_,17)*DYNX(DP_,0)
  *DYNX(DP_,1),"turbine.H_n*Const.g*Const.rho",DYNX(DP_,4),"Const.p_a"),
  "turbine.H_n*Const.g*Const.rho/Const.p_a"),"sqrt(turbine.H_n*Const.g*Const.rho/Const.p_a)"),
  "turbine.V_dot_n/sqrt(turbine.H_n*Const.g*Const.rho/Const.p_a)",DYNX(DP_,19),
  "turbine.u_n");
BoundParameterSection
InitialSection
InitialSection
InitialStartSection
InitialStartSection2
DYNX(W_,58) = DYNX(DP_,37);
DYNX(W_,59) = DYNX(DP_,36);
DYNX(X_,2) = DYNX(W_,64);
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)

OutputSection

DynamicsSection
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(F_,1) = RememberSimple_(DYNX(F_,1), 0);
SolveScalarLinearParametric( -DYNX(DYNhelp,0)," -1.0/Const.rho",  -DYNX(X_,2),
  " -pipe.V_dot", DYNX(F_,1),"der(airCushionSurgeTank.m)");
 /* End of Equation Block */ 

DYNX(F_,0) = 0.0;
 /* Linear system of equations to solve. */
DYNX(W_,4) = RememberSimple_(DYNX(W_,4), 1);
SolveScalarLinearParametric( -DYNX(DP_,1)*DYNX(DP_,11)," -Const.rho*reservoir.L",
    -DYNX(X_,0)," -reservoir.m", DYNX(W_,4),"reservoir.A");
 /* End of Equation Block */ 

{ /* Non-linear system of equations to solve. */
/* Tag: simulation.nonlinear[1] */
/* Introducing 6 common subexpressions used in 2 expressions */
/* Of the common subexpressions 6 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"reservoir.H"};
const double nominal_[]={1};
NonLinearSystemOfEquationsNH(Jacobian__, residue__, x__, 1, 0, 0, 1, 2, 1, 
  DYNX(DYNhelp,4), 37, DYNX(did_->helpvari_vec,0), 23);
NonLinearSystemSave(DYNX(W_,4), 0);
SetInitVectorNH(x__, 1, DYNX(W_,11), Remember_(DYNX(W_,11), 2));
Residues;
DYNX(DYNhelp,41) = 0.017453292519943295*DYNX(DP_,13);
if (NewParameters_) {
DYNX(DYNhelp,42) = tan(DYNX(DYNhelp,41));
}
DYNX(DYNhelp,43) = 2.0*DYNX(W_,11)*DYNX(DYNhelp,42);
DYNX(DYNhelp,44) = DYNX(DP_,12)+DYNX(DYNhelp,43);
SetVector(residue__, 1, DYNX(W_,4)-DYNX(W_,11)*DYNX(DYNhelp,44));

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1,  -(DYNX(DYNhelp,44)+DYNX(DYNhelp,43)));

SolveNonLinearSystemOfEquationsNH(Jacobian__, 0, 0, 0, residue__, x__, 1, 
  "Tag: simulation.nonlinear[1]");
DYNX(W_,11) = GetVector(x__, 1);
EndNonLinearSystemOfEquationsNH(residue__, x__, 1);
 /* End of Non-Linear Equation Block */ }



 /* Linear system of equations to solve. */
DYNX(W_,12) = RememberSimple_(DYNX(W_,12), 3);
SolveScalarLinear(DYNX(W_,4),"reservoir.A", DYNX(W_,4)*DYNX(DP_,4)+DYNX(DP_,0)*
  DYNX(DP_,1)*DYNX(W_,4)*DYNX(W_,11),"reservoir.A*Const.p_a+Const.g*Const.rho*reservoir.A*reservoir.H",
   DYNX(W_,12),"reservoir.p_2");
 /* End of Equation Block */ 

DYNX(W_,59) = DYNX(DYNhelp,0)*DYNX(F_,1);
if (NewParameters_) {
DYNX(DYNhelp,45) = divinvGuarded(DYNX(W_,51),"airCushionSurgeTank.A");
}
DYNX(W_,49) = DYNX(DYNhelp,45)*DYNX(W_,59);
 /* Linear system of equations to solve. */
DYNX(W_,52) = RememberSimple_(DYNX(W_,52), 4);
SolveScalarLinearParametric( -DYNX(DP_,1)*DYNX(W_,51)," -Const.rho*airCushionSurgeTank.A",
    -DYNX(X_,1)," -airCushionSurgeTank.m", DYNX(W_,52),"airCushionSurgeTank.l");
 /* End of Equation Block */ 

if (NewParameters_) {
DYNX(DYNhelp,46) = divinvGuarded(DYNX(W_,53),"airCushionSurgeTank.cos_theta");
}
DYNX(DYNhelp,47) = DYNX(DYNhelp,46)*DYNX(DP_,37);
DYNX(DYNhelp,48) = DYNX(DP_,34)-DYNX(W_,52);
DYNX(W_,57) = 4100000.0*powGuarded(divGuarded(DYNX(DP_,34)-DYNX(DYNhelp,47),
  "airCushionSurgeTank.L-airCushionSurgeTank.h_0/airCushionSurgeTank.cos_theta",
  DYNX(DYNhelp,48),"airCushionSurgeTank.L-airCushionSurgeTank.l"),
  "(airCushionSurgeTank.L-airCushionSurgeTank.h_0/airCushionSurgeTank.cos_theta)/(airCushionSurgeTank.L-airCushionSurgeTank.l)",
  DYNX(DP_,5),"Const.gamma_air");
DYNX(W_,54) = (PushModelContext(1,"OpenHPL.Functions.DarcyFriction.Friction(airCushionSurgeTank.v, airCushionSurgeTank.D, airCushionSurgeTank.l, Const.rho, Const.mu, airCushionSurgeTank.eps)")
  OpenHPL_Functions_DarcyFriction_Friction(DYNX(W_,49), DYNX(DP_,35), 
  DYNX(W_,52), DYNX(DP_,1), DYNX(DP_,2), DYNX(W_,45)));
PopModelContext();
if (NewParameters_) {
DYNX(DYNhelp,49) = divinvGuarded(DYNX(W_,69),"pipe.A_");
}
DYNX(W_,71) = DYNX(DYNhelp,49)*DYNX(X_,2);
DYNX(W_,72) = (PushModelContext(1,"OpenHPL.Functions.DarcyFriction.Friction(pipe.v, pipe.D_, pipe.L, Const.rho, Const.mu, pipe.eps)")
  OpenHPL_Functions_DarcyFriction_Friction(DYNX(W_,71), DYNX(W_,65), 
  DYNX(DP_,40), DYNX(DP_,1), DYNX(DP_,2), DYNX(W_,62)));
PopModelContext();

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[1] */
/* Introducing 9 common subexpressions and reusing 1 variables totally used in 9
   expressions */
/* Of the common subexpressions 10 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,50) = DYNX(DP_,1)*sqr(DYNX(W_,59));
DYNX(DYNhelp,51) = DYNX(DYNhelp,45)*DYNX(DYNhelp,50);
DYNX(DYNhelp,52) = DYNX(F_,1)*DYNX(W_,49);
DYNX(DYNhelp,53) = sqr(DYNX(X_,2));
if (NewParameters_) {
DYNX(DYNhelp,54) = divinvGuarded(DYNX(W_,67),"pipe.A_i");
}
if (NewParameters_) {
DYNX(DYNhelp,55) = divinvGuarded(DYNX(W_,68),"pipe.A_o");
}
/* Automatic tearing of linear system of 7 simultaneous equations
gave a linear system of 2 equations for numerical solution.*/
{
  const char*const varnames_[]={"airCushionSurgeTank.der(m, 2)", "turbine.p_tr1"};
  const double nominal_[]={1, 1e5};
  DidLinearSystemOfEquations(J, b, y, 2, DYNX(DYNhelp,56), 24, DYNX(did_->helpvari_vec,23), 8);
  /* Jacobian depending on continuous variables */
  SetNeedFactor(J);
  if (NeedFactor(J)) {
    MatrixZeros(J);
    DYNX(DYNhelp,80) = DYNX(DP_,1)*DYNX(DP_,40);
    SetMatrixLeading(J, 1, 1, 2, DYNX(DYNhelp,0)*DYNX(DYNhelp,45)*DYNX(X_,1));
    SetMatrixLeading(J, 1, 2, 2,  -DYNX(W_,51));
    SetMatrixLeading(J, 2, 1, 2, DYNX(DYNhelp,0)*DYNX(DYNhelp,80));
    SetMatrixLeading(J, 2, 2, 2, DYNX(W_,68));
  }
  SetVector(b, 1,  -(DYNX(W_,57)*DYNX(W_,51)-DYNX(DYNhelp,51)+DYNX(W_,54)+
    DYNX(X_,1)*DYNX(DP_,0)*DYNX(W_,53)+DYNX(DYNhelp,52)));
  SetVector(b, 2, DYNX(DP_,1)*DYNX(DYNhelp,53)*(DYNX(DYNhelp,54)-
    DYNX(DYNhelp,55))+DYNX(W_,12)*DYNX(W_,67)-DYNX(W_,72)+DYNX(W_,66)*
    DYNX(DP_,0)*DYNX(W_,70));
  SetVector(y, 1, RememberSimple_(DYNX(W_,48), 5));
  SetVector(y, 2, RememberSimple_(DYNX(W_,14), 6));
  SolveLinearSystemOfEquations(J, b, y, 1);
  DYNX(W_,48) = GetVector(y, 1);
  DYNX(W_,14) = GetVector(y, 2);
  EndStaticLinearSystemOfEquations(J);
}
DYNX(W_,60) = DYNX(DYNhelp,0)*DYNX(W_,48);
DYNX(W_,50) = DYNX(DYNhelp,45)*DYNX(W_,60);
DYNX(W_,56) = DYNX(DYNhelp,52)+DYNX(X_,1)*DYNX(W_,50);
DYNX(F_,2) = DYNX(W_,60);
DYNX(W_,74) = DYNX(DYNhelp,80)*DYNX(F_,2);
 /* End of Equation Block */ 


AcceptedSection1

AcceptedSection2
DYNX(W_,73) = DYNX(DP_,1)*DYNX(DP_,40)*DYNX(X_,2);
DYNX(W_,55) = DYNX(X_,1)*DYNX(W_,49);
 /* Linear system of equations to solve. */
DYNX(W_,5) = RememberSimple_(DYNX(W_,5), 7);
SolveScalarLinearParametric( -DYNX(DP_,1)," -Const.rho",  -DYNX(F_,1),
  " -der(airCushionSurgeTank.m)", DYNX(W_,5),"reservoir.V_o_dot");
 /* End of Equation Block */ 

DYNX(W_,23) = DYNX(DP_,45)+(IF LessTime(DYNX(DP_,46), 0) THEN 0 ELSE IF LessTime
  (DYNX(DP_,46)+DYNX(DP_,44), 1) THEN divGuarded((DYNTime-DYNX(DP_,46))*
  DYNX(DP_,43),"(time-control.startTime)*control.height",DYNX(DP_,44),
  "control.duration") ELSE DYNX(DP_,43));
DYNX(W_,26) = (PushModelContext(1,"Modelica.Blocks.Tables.Internal.getTable1DValue(\nturbine.look_up_table.tableID, \n1, \nturbine.u_t)")
  Modelica_Blocks_Tables_Internal_getTable1DValue_M(DymStruc0_construct(
  (Integer)(DYNX(W_,44))), 1, DYNX(W_,23)));
PopModelContext();
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(W_,58) = RememberSimple_(DYNX(W_,58), 8);
SolveScalarLinearParametric( -DYNX(DYNhelp,46)," -1.0/airCushionSurgeTank.cos_theta",
    -DYNX(W_,52)," -airCushionSurgeTank.l", DYNX(W_,58),"airCushionSurgeTank.h");
 /* End of Equation Block */ 

DYNX(W_,75) = DYNX(W_,14)-DYNX(W_,12);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareParameter("Const.g", "gravity [m/s2]", 0, 9.80665, 0.0,0.0,0.0,0,560)
DeclareParameter("Const.rho", "density [kg/m3|g/cm3]", 1, 997.0, 0.0,1E+100,0.0,\
0,560)
DeclareParameter("Const.mu", "dynamic viscosity of water [Pa.s]", 2, 0.00089, \
0.0,1E+100,0.0,0,560)
DeclareParameter("Const.eps", "pipe roughness height [m]", 3, 0.05, 0.0,1E+100,\
0.0,0,560)
DeclareParameter("Const.p_a", "Atmospheric pressure [Pa|bar]", 4, 101300.0, \
0.0,0.0,0.0,0,560)
DeclareParameter("Const.gamma_air", "Specific heat capacities ratio, Cp/Cv for air",\
 5, 1.4, 0.0,0.0,0.0,0,560)
DeclareParameter("Const.beta", "water compressibility [1/Pa]", 6, 4.5E-10, \
0.0,0.0,0.0,0,560)
DeclareVariable("Const.beta_total", "total compressibility [1/Pa]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("Const.Steady", "If checked - simulation starts from Steady State [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("Const.V_0", "Initial flow rate through the system [m3/s]", 7, \
19.077, 0.0,0.0,0.0,0,560)
DeclareParameter("Const.f", "Initial frequency [Hz]", 8, 50, 0.0,0.0,0.0,0,560)
DeclareParameter("Const.c_p", "[J/(kg.K)]", 9, 4200, 0.0,0.0,0.0,0,560)
DeclareParameter("reservoir.H_r", "Initial water level above intake [m]", 10, 6,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("reservoir.L", "Length of the reservoir [m]", 11, 500, 0.0,0.0,\
0.0,0,560)
DeclareParameter("reservoir.w", "Bed width of the reservoir [m]", 12, 100, \
0.0,0.0,0.0,0,560)
DeclareParameter("reservoir.alpha", "The angle of the reservoir walls (zero angle corresponds to vertical walls) [deg]",\
 13, 30, 0.0,0.0,0.0,0,560)
DeclareParameter("reservoir.f", "Friction factor of the reservoir", 14, 0.0008, \
0.0,0.0,0.0,0,560)
DeclareVariable("reservoir.UseInFlow", "If checked - the inlet/outlet flow is used [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("reservoir.Input_level", "If checked - the input Level_in should be connected. Otherwise the constant level H_r is used [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("reservoir.A", "vertiacal cros section [m2]", 0.0, 0.0,0.0,0.0,0,512)
DeclareState("reservoir.m", "water mass [kg]", 0, 0.0, 0.0,1E+100,0.0,0,560)
DeclareDerivative("reservoir.der(m)", "der(water mass) [kg/s]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareAlias2("reservoir.m_dot", "water mass flow rate [kg/s]", "reservoir.der(m)", 1,\
 6, 0, 0)
DeclareVariable("reservoir.V_o_dot", "outlet flow rate [m3/s]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareAlias2("reservoir.V_i_dot", "inlet flow rate [m3/s]", "reservoir.V_o_dot", 1,\
 5, 5, 0)
DeclareVariable("reservoir.V_dot", "vertical flow rate [m3/s]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("reservoir.v", "water velosity [m/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("reservoir.M", "water momentum [kg.m/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("reservoir.der(M)", "der(water momentum) [N]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("reservoir.F_f", "friction force [N]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("reservoir.H", "water height [m]", 0.0, 0.0,1E+100,0.0,0,576)
DeclareVariable("reservoir.p_2", "outside pressure [Pa|bar]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("reservoir.n.p", "Contact pressure [Pa|bar]", "reservoir.p_2", 1, 5,\
 12, 4)
DeclareAlias2("reservoir.n.m_dot", "Mass flow rate through the contact [kg/s]", \
"airCushionSurgeTank.der(m)", -1, 6, 1, 132)
DeclareParameter("turbine.ValveCapacity", "If checked the guide vane capacity C_v should be specified, otherwise specify the nominal turbine parameters (net head and flow rate) [:#(type=Boolean)]",\
 15, false, 0.0,0.0,0.0,0,562)
DeclareParameter("turbine.C_v", "Guide vane 'valve capacity'", 16, 3.7, 0.0,0.0,\
0.0,0,560)
DeclareParameter("turbine.H_n", "Turbine nominal net head [m]", 17, 445, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("turbine.V_dot_n", "Turbine nominal flow rate [m3/s]", 18, 17.5,\
 0.0,0.0,0.0,0,560)
DeclareParameter("turbine.u_n", "Turbine guide vane nominal opening, pu", 19, \
0.95, 0.0,0.0,0.0,0,560)
DeclareVariable("turbine.ConstEfficiency", "If checked the constant efficiency theta_h is used,    otherwise specify lookup table for efficiency [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("turbine.theta_h", "Turbine hydraulic efficiency [1]", 20, 0.9,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("turbine.lookup_table[1, 1]", "Look-up table for the turbine efficiency, described by a table matrix, where the first column is a pu value of the guide vane opening, and the second column is a pu value of the turbine efficiency",\
 21, 0.0, 0.0,0.0,0.0,0,560)
DeclareParameter("turbine.lookup_table[1, 2]", "Look-up table for the turbine efficiency, described by a table matrix, where the first column is a pu value of the guide vane opening, and the second column is a pu value of the turbine efficiency",\
 22, 0.4, 0.0,0.0,0.0,0,560)
DeclareParameter("turbine.lookup_table[2, 1]", "Look-up table for the turbine efficiency, described by a table matrix, where the first column is a pu value of the guide vane opening, and the second column is a pu value of the turbine efficiency",\
 23, 0.2, 0.0,0.0,0.0,0,560)
DeclareParameter("turbine.lookup_table[2, 2]", "Look-up table for the turbine efficiency, described by a table matrix, where the first column is a pu value of the guide vane opening, and the second column is a pu value of the turbine efficiency",\
 24, 0.7, 0.0,0.0,0.0,0,560)
DeclareParameter("turbine.lookup_table[3, 1]", "Look-up table for the turbine efficiency, described by a table matrix, where the first column is a pu value of the guide vane opening, and the second column is a pu value of the turbine efficiency",\
 25, 0.5, 0.0,0.0,0.0,0,560)
DeclareParameter("turbine.lookup_table[3, 2]", "Look-up table for the turbine efficiency, described by a table matrix, where the first column is a pu value of the guide vane opening, and the second column is a pu value of the turbine efficiency",\
 26, 0.9, 0.0,0.0,0.0,0,560)
DeclareParameter("turbine.lookup_table[4, 1]", "Look-up table for the turbine efficiency, described by a table matrix, where the first column is a pu value of the guide vane opening, and the second column is a pu value of the turbine efficiency",\
 27, 0.95, 0.0,0.0,0.0,0,560)
DeclareParameter("turbine.lookup_table[4, 2]", "Look-up table for the turbine efficiency, described by a table matrix, where the first column is a pu value of the guide vane opening, and the second column is a pu value of the turbine efficiency",\
 28, 0.95, 0.0,0.0,0.0,0,560)
DeclareParameter("turbine.lookup_table[5, 1]", "Look-up table for the turbine efficiency, described by a table matrix, where the first column is a pu value of the guide vane opening, and the second column is a pu value of the turbine efficiency",\
 29, 1.0, 0.0,0.0,0.0,0,560)
DeclareParameter("turbine.lookup_table[5, 2]", "Look-up table for the turbine efficiency, described by a table matrix, where the first column is a pu value of the guide vane opening, and the second column is a pu value of the turbine efficiency",\
 30, 0.93, 0.0,0.0,0.0,0,560)
DeclareParameter("turbine.WaterCompress", "If checked the water is compressible in the penstock [:#(type=Boolean)]",\
 31, false, 0.0,0.0,0.0,0,562)
DeclareVariable("turbine.p_tr1", "Inlet pressure [Pa|bar]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("turbine.dp", "Turbine pressure drop [Pa|bar]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareAlias2("turbine.p_tr2", "Outlet pressure [Pa|bar]", "turbine.p_tr1", 1, 5,\
 14, 0)
DeclareVariable("turbine.K_tr1_dot", "Kinetic energy [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.V_dot", "Flow rate [m3/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.C_v_", "Guide vane 'valve capacity'", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("turbine.W_s_dot", "Shaft power [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.m_dot", "Mass flow rate [kg/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("turbine.p.p", "Contact pressure [Pa|bar]", "turbine.p_tr1", 1, 5,\
 14, 4)
DeclareVariable("turbine.p.m_dot", "Mass flow rate through the contact [kg/s]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("turbine.n.p", "Contact pressure [Pa|bar]", "turbine.p_tr1", 1, 5,\
 14, 4)
DeclareVariable("turbine.n.m_dot", "Mass flow rate through the contact [kg/s]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("turbine.u_t", "[Guide vane|nozzle] opening of the turbine", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("turbine.P_out", "Mechanical Output power [W]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("turbine.look_up_table.n", "Number of inputs (= number of outputs) [:#(type=Integer)]",\
 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("turbine.look_up_table.u[1]", "Connector of Real input signals", \
"turbine.u_t", 1, 5, 23, 0)
DeclareVariable("turbine.look_up_table.y[1]", "Connector of Real output signals",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("turbine.look_up_table.tableOnFile", "= true, if table is defined on file or in function usertab [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("turbine.look_up_table.table[1, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.look_up_table.table[1, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.look_up_table.table[2, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.look_up_table.table[2, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.look_up_table.table[3, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.look_up_table.table[3, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.look_up_table.table[4, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.look_up_table.table[4, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.look_up_table.table[5, 1]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.look_up_table.table[5, 2]", "Table matrix (grid = first column; e.g., table=[0, 0; 1, 1; 2, 4])",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareParameter("turbine.look_up_table.verboseRead", "= true, if info message that file is loading is to be printed [:#(type=Boolean)]",\
 32, true, 0.0,0.0,0.0,0,562)
DeclareVariable("turbine.look_up_table.columns[1]", "Columns of table to be interpolated [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("turbine.look_up_table.smoothness", "Smoothness of table interpolation [:#(type=Modelica.Blocks.Types.Smoothness)]",\
 1, 1.0,5.0,0.0,0,517)
DeclareVariable("turbine.look_up_table.extrapolation", "Extrapolation of data outside the definition range [:#(type=Modelica.Blocks.Types.Extrapolation)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("turbine.look_up_table.verboseExtrapolation", "= true, if warning messages are to be printed if table input is outside the definition range [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("turbine.look_up_table.u_min", "Minimum abscissa value defined in table",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.look_up_table.u_max", "Maximum abscissa value defined in table",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("turbine.look_up_table.tableID.id", "[:#(type=Integer)]", 0, \
0.0,0.0,0.0,0,2565)
DeclareParameter("airCushionSurgeTank.H", "Vertical component of the length of the surge shaft [m]",\
 33, 10.5, 0.0,1E+100,0.0,0,560)
DeclareParameter("airCushionSurgeTank.L", "Length of the surge shaft [m]", 34, \
12.12, 0.0,0.0,0.0,0,560)
DeclareParameter("airCushionSurgeTank.D", "Diameter of the surge shaft [m]", 35,\
 50.47, 0.0,1E+100,0.0,0,560)
DeclareVariable("airCushionSurgeTank.eps", "Pipe roughness height [m]", 0.0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("airCushionSurgeTank.SteadyState", "if true - starts from Steady State [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareParameter("airCushionSurgeTank.V_dot0", "Initial flow rate in the surge tank [m3/s]",\
 36, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("airCushionSurgeTank.h_0", "Initial water height in the surge tank [m]",\
 37, 2, 0.0,1E+100,0.0,0,560)
DeclareVariable("airCushionSurgeTank.p_air", "Initial pressure of air cushion [Pa|Pa]",\
 4100000.0, 0.0,0.0,0.0,0,513)
DeclareState("airCushionSurgeTank.m", "water mass [kg]", 1, 0.0, 0.0,1E+100,0.0,\
0,560)
DeclareDerivative("airCushionSurgeTank.der(m)", "der(water mass) [kg/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("airCushionSurgeTank.der(m, 2)", "der(water mass2) [kg/s2]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("airCushionSurgeTank.v", "water velocity [m/s]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("airCushionSurgeTank.der(v)", "der(water velocity) [m/s2]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("airCushionSurgeTank.A", "cross section area [m2]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("airCushionSurgeTank.l", "length of water in the surge tank [m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("airCushionSurgeTank.cos_theta", "slope ratio [1]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("airCushionSurgeTank.F_f", "friction force [N]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("airCushionSurgeTank.M", "water momuntum [kg.m/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("airCushionSurgeTank.der(M)", "der(water momuntum) [N]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("airCushionSurgeTank.p_2", "pressure of air cushion [Pa|bar]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("airCushionSurgeTank.h", "water height in the surge tank [m]", \
0.0, 0.0,1E+100,0.0,0,512)
DeclareVariable("airCushionSurgeTank.V_dot", "water flow rate [m3/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("airCushionSurgeTank.der(V_dot)", "der(water flow rate) [m3/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("airCushionSurgeTank.p_n", "Node pressure [Pa|bar]", \
"turbine.p_tr1", 1, 5, 14, 0)
DeclareAlias2("airCushionSurgeTank.m_dot", "Mass flow rate [kg/s]", \
"airCushionSurgeTank.der(m)", 1, 6, 1, 0)
DeclareAlias2("airCushionSurgeTank.p.p", "Contact pressure [Pa|bar]", \
"turbine.p_tr1", 1, 5, 14, 4)
DeclareAlias2("airCushionSurgeTank.p.m_dot", "Mass flow rate through the contact [kg/s]",\
 "airCushionSurgeTank.der(m)", 1, 6, 1, 132)
DeclareAlias2("airCushionSurgeTank.n.p", "Contact pressure [Pa|bar]", \
"turbine.p_tr1", 1, 5, 14, 4)
DeclareVariable("airCushionSurgeTank.n.m_dot", "Mass flow rate through the contact [kg/s]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareParameter("pipe.vertical", "Display vertical icon instead [:#(type=Boolean)]",\
 38, false, 0.0,0.0,0.0,0,562)
DeclareParameter("pipe.H", "Height difference from the inlet to the outlet [m]",\
 39, 345, 0.0,0.0,0.0,0,560)
DeclareParameter("pipe.L", "Length of the pipe [m]", 40, 8862.21, 0.0,0.0,0.0,0,560)
DeclareParameter("pipe.D_i", "Diameter of the inlet side [m]", 41, 6.56, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("pipe.D_o", "Diameter of the outlet side [m]", 42, 6.56, 0.0,\
1E+100,0.0,0,560)
DeclareVariable("pipe.eps", "Pipe roughness height [m]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("pipe.SteadyState", "if true - starts from Steady State [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("pipe.V_dot0", "Initial flow rate in the pipe [m3/s]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("pipe.D_", "Average diameter [m]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("pipe.m", "water mass [kg]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("pipe.A_i", "Inlet cross section area [m2]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.A_o", "Outlet cross section area [m2]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.A_", "Average cross section area [m2]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.cos_theta", "slope ratio [1]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("pipe.v", "Water velocity [m/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.F_f", "Friction force [N]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.M", "Water momentum [kg.m/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("pipe.der(M)", "der(Water momentum) [N]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("pipe.p_1", "Inlet pressure [Pa|bar]", "reservoir.p_2", 1, 5, 12, 0)
DeclareAlias2("pipe.p_2", "Outlet pressure [Pa|bar]", "turbine.p_tr1", 1, 5, 14,\
 0)
DeclareVariable("pipe.dp", "Pressure difference p_2-p_1 [Pa|bar]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareState("pipe.V_dot", "Flow rate [m3/s]", 2, 0.0, 0.0,0.0,0.0,1,560)
DeclareDerivative("pipe.der(V_dot)", "der(Flow rate) [m3/s2]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareAlias2("pipe.m_dot", "Mass flow rate [kg/s]", "airCushionSurgeTank.der(m)", 1,\
 6, 1, 0)
DeclareAlias2("pipe.p.p", "Contact pressure [Pa|bar]", "reservoir.p_2", 1, 5, 12,\
 4)
DeclareAlias2("pipe.p.m_dot", "Mass flow rate through the contact [kg/s]", \
"airCushionSurgeTank.der(m)", 1, 6, 1, 132)
DeclareAlias2("pipe.n.p", "Contact pressure [Pa|bar]", "turbine.p_tr1", 1, 5, 14,\
 4)
DeclareAlias2("pipe.n.m_dot", "Mass flow rate through the contact [kg/s]", \
"airCushionSurgeTank.der(m)", -1, 6, 1, 132)
DeclareParameter("control.height", "Height of ramps", 43, 0.346, 0.0,0.0,0.0,0,560)
DeclareParameter("control.duration", "Duration of ramp (= 0.0 gives a Step) [s]",\
 44, 50, 0.0,1E+100,0.0,0,560)
DeclareAlias2("control.y", "Connector of Real output signal", "turbine.u_t", 1, 5,\
 23, 0)
DeclareParameter("control.offset", "Offset of output signal y", 45, 0.48, \
0.0,0.0,0.0,0,560)
DeclareParameter("control.startTime", "Output y = offset for time < startTime [s]",\
 46, 50, 0.0,0.0,0.0,0,560)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartEqBlock
if (final_==2) {
DYNX(W_,58) = DYNX(DP_,37);
}
DoRememAcc_(DYNX(W_,58), DYNX(DP_,37), 8);
DoRemember_(DYNX(W_,52), 0.0, 4);
DoRemember_(DYNX(F_,1), 0.0, 0);
DoRemember_(DYNX(W_,48), 0.0, 5);
DoRemember_(DYNX(W_,4), 0.0, 1);
DoRemember_(DYNX(W_,11), 0.0, 2);
DoRememAcc_(DYNX(W_,5), 0.0, 7);
DoRemember_(DYNX(W_,12), 0.0, 3);
DoRemember_(DYNX(W_,14), 0.0, 6);
EndEqBlock
EndDataBlock
